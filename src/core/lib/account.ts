/* Global Imports */

import { Buff }            from '@cmdcode/buff'
import { parse_addr }      from '@scrow/tapscript/address'
import { create_sequence } from '@scrow/tapscript/tx'

import {
  get_key_ctx,
  tweak_key_ctx
} from '@cmdcode/musig2'

/* Module Imports */

import { Network } from '@/types.js'
import { get_object_id, now, sort_record } from '@/util.js'

/* Local Imports */

import { get_recovery_script }     from './recovery.js'
import { get_address, get_tapkey } from './tx.js'

import {
  gen_session_token,
  parse_session_token
} from './session.js'

import {
  AccountData,
  AccountContext,
  AccountRequest,
  SignerAPI,
  SessionToken,
  AccountTemplate
} from '../types/index.js'

import AcctSchema from '../schema/account.js'

/**
 * Create an account request object.
 */
export function create_account_req (
  deposit_pk  : string,
  locktime    : number,
  network     : Network,
  return_addr : string
) : AccountRequest {
  // Parse and return a valid account request object.
  return AcctSchema.request.parse({ deposit_pk, locktime, network, return_addr })
}

/**
 * Create an account data object.
 *
 * NOTE: The return address is used to index the signature session
 * generated by the counter-party. The resulting deposit address
 * is deterministic, which provides idempotency to the request.
 *
 * The deposit address should be checked by the counter-party for
 * prior use on the blockchain, and if used, reject the request.
 */
export function create_account (
  request   : AccountRequest,
  server_sd : SignerAPI,
  created_at = now()
) : AccountData {
  // Unpack the request object.
  const { deposit_pk, locktime, network, return_addr } = request
  // Get signing agent for account.
  const agent        = get_account_agent(request, server_sd)
  // Generate a session token.
  const session      = gen_session_token(agent, created_at)
  // Define the token string for the agent.
  const agent_tkn    = session.tkn
  // Create a context object for the account.
  const acct_ctx     = create_account_ctx(deposit_pk, locktime, network, return_addr, session)
  // Compute the deposit address from the account context.
  const deposit_addr = acct_ctx.deposit_addr
  // Pack the account object in prep for signing.
  const acct = { agent_tkn, deposit_addr, deposit_pk, locktime, network, return_addr }
  // Compute the id for the account data.
  const acct_id = get_object_id(acct)
  // Sign the account identifier.
  const sig = server_sd.sign(acct_id)
  // Return the complete account data object.
  return sort_record({ ...acct, acct_id: acct_id.hex, sig })
}

/**
 * Create an account context object.
 */
export function create_account_ctx (
  deposit_pk  : string,
  locktime    : number,
  network     : Network,
  return_addr : string,
  session     : SessionToken
) : AccountContext {
  // Define the members of the multi-sig.
  const members      = [ deposit_pk, session.pk ]
  // Get the sequence value from the locktime.
  const sequence     = create_sequence('stamp', locktime)
  // Get the context of the return address.
  const addr_ctx     = parse_addr(return_addr)
  // Get the recovery script path.
  const script       = get_recovery_script(addr_ctx.key, sequence)
  // Get the musig context for the internal key.
  const int_data     = get_key_ctx(members)
  // Get the key data for the taproot key.
  const tap_data     = get_tapkey(int_data.group_pubkey.hex, script)
  // Get the musig context for the tap-tweaked key.
  const key_data     = tweak_key_ctx(int_data, [ tap_data.taptweak ])
  // Get the deposit address from the taproot data.
  const deposit_addr = get_address(tap_data.tapkey, addr_ctx.network)
  // Ensure that the return address is a taproot address.
  if (addr_ctx.type !== 'p2tr') {
    throw new Error('only taproot addresses are valid for recovery')
  }
  // Return context object.
  return { deposit_addr, deposit_pk, key_data, network, return_addr, script, sequence, session, tap_data }
}

/**
 * Get the context object from an existing account.
 */
export function get_account_ctx (template : AccountTemplate) {
  // Unpack the account object.
  const { agent_tkn, deposit_pk, locktime, network, return_addr } = template
  // Parse session token.
  const session = parse_session_token(agent_tkn)
  // Return the account context object.
  return create_account_ctx(deposit_pk, locktime, network, return_addr, session)
}

/**
 * Get the hash identifier for an account reqeust.
 */
export function get_account_hash (
  request : AccountRequest
) : string {
  const { deposit_pk, locktime, network, return_addr } = request
  const net = Buff.str(network)
  const pub = Buff.bytes(deposit_pk)
  const seq = Buff.num(locktime, 4)
  const rta = Buff.str(return_addr)
  return Buff.join([ net, pub, seq, rta ]).digest.hex
}

/**
 * Get the account id for a deposit account.
 */
export function get_account_id (
  address  : string,
  req_hash : string,
  stamp    : number
) : string {
  const addr = Buff.str(address)
  const hash = Buff.hex(req_hash)
  const stmp = Buff.num(stamp, 4)
  return Buff.join([ addr, hash, stmp ]).digest.hex
}

export function get_account_agent (
  request   : AccountRequest,
  server_sd : SignerAPI
) {
  // Get account request hash.
  const hash = get_account_hash(request)
  // Get signing agent for account.
  return server_sd.get_id(hash)
}
